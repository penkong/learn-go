install go lang 
add extentsions for vscode 
install analyze tools 
gopkgs
  go-outline
  gotests
  gomodifytags
  impl
  goplay
  dlv
  golint
  gopls

---
go env 

main.go
how run code?
go in folder > go run main.go

go fmt > format files 
go build > compile 
go run > compile and execute
go install > compile and install a package
go get > dl source code of package (someone elese)
go test > run stest

--- 

what is 'package main'?

package == project == workspace

package (many go file in it  )
each file in workspace need have package name 
that belong to .

there are 2 type of packages
executable : generate a file we can run
(word main is important)

reusable : code use as helper, good place to put 
reuse logic
(package calculator)

---

what is import fmt ?
allow access to other code 

math, encoding , debug , fmt , crypto , io

golang.org/pkg

also can import other reuse packages

---

steps in go file :
package declaration
list of imports 
declaration of functions

---

CARDS PROJECT :
get file , read file , write to file , and functions

create new var with string ,
var card string = 'Ace of space'

string
bool
int 
float64

short form , 
card := "Ace of spades"

after	card = "Five of Diamonds"

--- 

return type of functions

func sth() string {}

---

array : fixed length

slice : an shrinkable array 
cards := []string{newCard(), newCard()}

only with one data type 

how add to slice?
with append 
it return new slice and attach it to var ,
append(<name of oldVar>, "info")

how iterate over slice ?
for i, card := range cards {
  fmt.Println(i, card)
}

---

OOP approach vs Go approach

type : tell go what we are going to do ,
receiver function : it is like method , 

define a file type how our functionality going to
work and treat .


and use that type in main file 
and run project like 

go run main.go deck.go

now func receiver 
func (d deck) print() {
	for i,card := range d {
		fmt.Println(i,card)
	}
}

now the any var defined with type of deck have 
access to print functions.

d is actual copy of the deck we are working with
available in the function a var called .

slice cards == d == like this , self 

type is like class declaration,
and funcs are methods .


add new functionality to understand go syntax


can pick slice from slice 
deck[startIndex:upToNotIncludingIndex]
deck[:2] // slice of 0,1
deck[2:] // slice of 6



receiver methods are like static methods 


noraml function get info


go has support to return multiple value from 
func
func deal(d deck, handSize int) (deck, deck) {
  	return d[:handSize], d[handSize:]
}

hand, remainingCards := deal(cards, 5)


---

byte slice : []byte

save to file ,
package ioutil


type conversion in go 
type we want    value we have
[]byte           ("hi there")

deck => []string => join => []byte
package Stings



null is nil

len == length 

Math.random = rand.Intn
go use seed for generator of random 

---

test with go 

go test go

func TestNewDeck(t *testing.T) {}
t is test handler

---

struct 
data structure . collection of props thatr are related together.
card struct => suit , value 
struct like plain object in js .


type person struct {
  firstName string
  lastName string
  contact contactInfo<cutom type>
}
alex := person{"Alex", "Anderson"}

in go when define var and dont assign anything to it 
go assign zero value by itself

string, int, float, bool

fmt.Printf(identifier, actual value)
"%+v" => % field names , v their values

also you can add struct as item for receiver func

but update value in struct normally does not work 

pointers in go 

go is pass by value

struct with pointers

jimPointer := &jim
(pointerToPerson *person)
*person is pointer

&variable : & is operator , give me the memory address of the value this variable
  is pointing to (give memory address)

&var = memory address


// read like this : a pointer that point to sth
*pointer : * give me the value this memory address is pointing to.
// take this memory address and give me the value

*point = value in that memory address.

(pointerToPerson *person)

*person means : type description , means we are working with pointer of type person

*pointerToPerson : an operator , means we want manipulate the value the pointer is refering to.


turn address into value with *address
turn value into address with &value


shortcut : go infer for us &var , we can only do *type and go take memory address and 
make it ready for pointer varpoiner = &var

//

gotchas :

struct vs slice 
struct change need pointer 
but slice not 
it is like object and normal val in js .

slice : go make 2 data structure , slice , and array
new slice container 3 part , pointer to head of array , capacity, length 

slice --> go --> new slice (pointer , capacity, length) --> array by go 

value tpyes in go : int , float, string , bool , struct 
(for change need pointers in a function)

reference type in go : slices , maps , channels , pointers ,  fucntions
(dont worry about pointers with this)

---
================================================================================

go2 
make workspace 
with 3 dir`
bin pkg src


go get -d -x -v "address"


go fmt = format current dir
go fmt ./... = format everything


go install 
for exe : put in gopath/bin  , compile program

for package : put in gopath/pkg , compile package , make it archive file .

------


















