install go lang 
add extentsions for vscode 
install analyze tools 
gopkgs
  go-outline
  gotests
  gomodifytags
  impl
  goplay
  dlv
  golint
  gopls

---
go env 

main.go
how run code?
go in folder > go run main.go

go fmt > format files 
go build > compile 
go run > compile and execute
go install > compile and install a package
go get > dl source code of package (someone elese)
go test > run stest

--- 

what is 'package main'?

package == project == workspace

package (many go file in it  )
each file in workspace need have package name 
that belong to .

there are 2 type of packages
executable : generate a file we can run
(word main is important)

reusable : code use as helper, good place to put 
reuse logic
(package calculator)

---

what is import fmt ?
allow access to other code 

math, encoding , debug , fmt , crypto , io

golang.org/pkg

also can import other reuse packages

---

steps in go file :
package declaration
list of imports 
declaration of functions

---

CARDS PROJECT :
get file , read file , write to file , and functions

create new var with string ,
var card string = 'Ace of space'

string
bool
int 
float64

short form , 
card := "Ace of spades"

after	card = "Five of Diamonds"

--- 

return type of functions

func sth() string {}

---

array : fixed length

slice : an shrinkable array 
cards := []string{newCard(), newCard()}

only with one data type 

how add to slice?
with append 
it return new slice and attach it to var ,
append(<name of oldVar>, "info")

how iterate over slice ?
for i, card := range cards {
  fmt.Println(i, card)
}

---

OOP approach vs Go approach

type : tell go what we are going to do ,
receiver function : it is like method , 

define a file type how our functionality going to
work and treat .


and use that type in main file 
and run project like 

go run main.go deck.go

now func receiver 
func (d deck) print() {
	for i,card := range d {
		fmt.Println(i,card)
	}
}

now the any var defined with type of deck have 
access to print functions.

d is actual copy of the deck we are working with
available in the function a var called .

slice cards == d == like this , self 

type is like class declaration,
and funcs are methods .


add new functionality to understand go syntax


can pick slice from slice 
deck[startIndex:upToNotIncludingIndex]
deck[:2] // slice of 0,1
deck[2:] // slice of 6



receiver methods are like static methods 


noraml function get info


go has support to return multiple value from 
func
func deal(d deck, handSize int) (deck, deck) {
  	return d[:handSize], d[handSize:]
}

hand, remainingCards := deal(cards, 5)


---

byte slice : []byte

save to file ,
package ioutil


type conversion in go 
type we want    value we have
[]byte           ("hi there")

deck => []string => join => []byte
package Stings



null is nil

len == length 

Math.random = rand.Intn
go use seed for generator of random 

---

test with go 

go test go

func TestNewDeck(t *testing.T) {}
t is test handler

---

struct 
data structure . collection of props thatr are related together.
card struct => suit , value 
struct like plain object in js .


type person struct {
  firstName string
  lastName string
  contact contactInfo<cutom type>
}
alex := person{"Alex", "Anderson"}

in go when define var and dont assign anything to it 
go assign zero value by itself

string, int, float, bool

fmt.Printf(identifier, actual value)
"%+v" => % field names , v their values

also you can add struct as item for receiver func

but update value in struct normally does not work 

pointers in go 

go is pass by value

struct with pointers

jimPointer := &jim
(pointerToPerson *person)
*person is pointer

&variable : & is operator , give me the memory address of the value this variable
  is pointing to (give memory address)

&var = memory address


// read like this : a pointer that point to sth
*pointer : * give me the value this memory address is pointing to.
// take this memory address and give me the value

*point = value in that memory address.

(pointerToPerson *person)

*person means : type description , means we are working with pointer of type person

*pointerToPerson : an operator , means we want manipulate the value the pointer is refering to.


turn address into value with *address
turn value into address with &value


shortcut : go infer for us &var , we can only do *type and go take memory address and 
make it ready for pointer varpoiner = &var

//

gotchas :

struct vs slice 
struct change need pointer 
but slice not 
it is like object and normal val in js .

slice : go make 2 data structure , slice , and array
new slice container 3 part , pointer to head of array , capacity, length 

slice --> go --> new slice (pointer , capacity, length) --> array by go 

value tpyes in go : int , float, string , bool , struct 
(for change need pointers in a function)

reference type in go : slices , maps , channels , pointers ,  fucntions
(dont worry about pointers with this)

---

Map: 
all keys must be same type 
all value must be same type 

3 way to declare with make , with normal way , with init 
map[string]string


structs is better than map
we can not iterate over struct

when you know keys use struct
when dont know about things comming use map

---

interfaces :

if anything satisfy interface things 
it become automatically type of interface

interfaces are blueprint for struct
rules 

type sth interface {
  sths(list of argument) (list of return types)
}



concrete type : can produce value out of it like
map , string ,int , struct , cutstom struct


interface type 


------------------

HTTP :

normal http get dont bring back body of req

an interface can embed another interface

Body has type of interface 
that means Body can be anything as long as satisfy inteface


source of data --> Reader i --> []byte --> Writer i


-----------------------

channels and gorouting :









================================================================================

go2 
make workspace 
with 3 dir`
bin pkg src


go get -d -x -v "address"


go fmt = format current dir
go fmt ./... = format everything


go install 
for exe : put in gopath/bin  , compile program

for package : put in gopath/pkg , compile package , make it archive file .

--- 

go modules :

go mod init : init new module 
go build , test 
go list -m all : print current module dependencies
go get <package name> : bring latest one  
go mod tidy : remove unused .



go mod init example/user/repo
make module out of your file 


if we import a dependency it auto add 
to mod as dependency and go.sum file will 
add also show dependency in dependency


go list -m -versions <package name>
go get <pacakge with @number>
go test  


-----

controll flow :

1 ) sequence 
2 ) loop 
3 ) conditional

read control flow wiki



every value is type of interface {}


identifiers name program entities .


var keyword work outside of func body also .
 
type and value 

// show type of var 
fmt.Printf("%T\n", var)


conversion no casting 
a = int(b)

------

...interface {} == "variadic parameter"
give the func as many as item from one type as you want 


every value in go is type of empty interface = interface{}

---------------------------------

bool type : true false 


how computer works??


int without decimal 
float with decimal = real numbers


byte in go is alias for unit8
character utf ascii == rune in go is alias for int32

check 
fmt.Println(runtime.GOOS)
fmt.Println(runtime.GOARCH)


nacl os 

----------


string :

a string value is sequence of bytes = slice of bytes

[]byte(stringYour)

[]byte = []uint8

// show utf code  
fmt.Println("%#U" , string[i])

-------------------

numerical :

abcdef
101112131415

binary 2^0 
"%b\n", n
hexa  16^0
"%x\n"
base64 64^0

---------------------
const sl = 'sl'
const ( a = 43 b = 'sfsd' c true)


-------------------------------

IOTA :

pre declare identifier 
automatically increment data 
const a = IOTA
const b = IOTA
const c = IOTA
const d = IOTA
1,2,3,4


------------------------------------

Bit shifting : 

"%d" : decimal 
"%b" : binary 
x := 4 
y := x << 1 ===> y = 8


kb = 1 << 10 (add 10 zero to 1)
kb =  1 << (iota * 10)



raw string literals ``

-------------------------------------------------

Control flow :

switch "value"{
  // this will exec
  case "value" :

  // multi case value
  case "value1" , "value3", "value4" :
  case :
    fmt.fdsfsd()
    // will exec all other valid case below
    fallthrough

  case : 
  default :
    sfdsfew()
}

-------------------------------------------

group data :

array : 
var x [5]int 


slices :
slice is agregate


agregate : value of same type
struct : value of different types


composite type - literals:
slice
x := type {values}
x := []int{3,4,5,6,7,8}



if looping over map slice or ... use range



slice , slice :
x := []int{3,4,5,6,7,8}
x[:3] x[3:]



append to slice :

append(x, 4,5,6)


append slice to slice :

variadic parameters : y...
append(x , y...)


delete from slice :
append(x[:2], x[4:]...)



slice make :

built in make 
make() specify size of underlying array of slice

make([]int , 10 length, 100 capacity)
len(x)
cap(x)
use append to add to this slice built with make()
when size come over it make new added array with length of cap(x)
cap(x) ==> 2* cap(x)


multi dimensial slice :

jb := []string{}
jd := []string{}

xp := [][]string{jb, jd}

---------------------


maps :
key value store

m := map[string]int{
  "james" : 32,
  "miss" : 27, 
}

check that exists
if v does not exist bring back 0 
we need to way to determine if it exist 
v, ok := m["sonny"]
 
// famous
if v, ok := m["sonny"]; ok {

}



add to map :


m["tod"] = 343

for k, v := range x {
  fmt.Println(k,v)
}



map delete :

delete(mapName , "key")



another map :
m := map[string][]string{
  "mk" : []string{ "", ""}
}

-----------------------------


struct :
a data structure that let us compose values of different types

type person struct {
  first string
  last string
  age int
}

p1 := person {
  first: 'fsdf"
  last : 'fsdfs'
}
created value of type person

annonymous struct :

struct{firstName string}{ firstName: "mfsdf"}


------------------

functions :


reciever : attached to type 

 


variadic parameters : 

// many values become slice 
func foo (x ...int) {}


unferling a slice :
m = []int{}
m... => pull values of slice and put it in new location we use 

---

defer :
defer execution of function until define by us

defer foo()
bar()

----

Methods :

type person struct {}

func (p person) speak() {}


attach functio to that type.


-----------------------------------------

interfaces & polymorphism :

interfaces allow us to define behavior .
also do polymorphism with that 


type human interface {
  speak()
}

a value can be more than one type , type human , type person

any type that have speak() is type of human

assertion :
if h is type of person
h.(person).first
h.(agent).letToKill

------------------------------

annonymous func :

func main () {
  func(x int) {

  }(43)
}


---------------------------

func expresson :

f := func() {

}

f()

-----------------------------

return func from func :

funct foo() func() int {
  return func() int {
    return 451
  }
}

------------------------------

callback : 

passing func as argument


func even(f func(xi ...int) int , vi ...int) int {
  do sth with vi
  return f(vi)
}

-----------------------------

closure :
when closing var in its scope 

-----------------------------

recursion :

not good idea .

a function call itself .


-------------------------------------


Pointers :

& : show address in memory 
pointer in memory 

when check somthing T with & it show 
us type of pointer *int or *string

what is stored on that & > pointer with *int value 



*somevar : de reference pointer and show value stored in that
address.

b = *&b

also it let u assign new value to that 
a = 'old value'
b := &a
*b = 'new value'


use to pass address pointer rather than data 
or if you want change something in locations.


when value want to mutate use pointer.


---------------

method set :

those methods attached to a type named set 

what is set of methods attached to type => method set 

non pointer reciever
pointer reciever



-------------------


Application :

marshaling :

json.Marshall
struct -> json 

de marshaling :

string is sequence of bytes

jsonBlob = []byte
json  -> struct 

json.Unmarshal(blob , &var = must be pointer)
json ->  conversion to []byte -> Unmarshal



------------

Writer interface :

encode , decode (like marshal)
Reader , Writer

writer : write it to out source 
reader : incoming info

type writer is interface ,
with 
Write(p []byte) (n int , err error)

-----------------------

Sort :

slice -> sort


sort.Ints(slice of int)
sort.Strings()

slice is type length capacity
 

sort cutstom :
 

Interface inteface :
3 method on it 
len swap less


-----------------------

bycrypt : 

from crypto 


------------------------


Concurrency :


Concurrency vs Parallelism 

Parallelism is code run in one time 

Concurrency is a design pattern

runtime :

NumCPU()
NumGorouteins()
A Goroutine is a function or method which executes independently and 
simultaneously in connection with any other Goroutines present in your program.

make new goroutine with go f()
it add one to goroutine 
but we need to tell to main() wait because when go pass go f() it exec whole main 
and program exit but we need wait go f() resolve

WaitGroup : package sync
// pacakge scope 
var wg sync.WaitGroup
wg. add dont wait 3 methods 
add wg.add()
add wg.done() to f()

and in end of main write wg.wait()


check effective go Concurrency


--------------------------

Race condition :

normally when use go f() it happen 
we use runtime.Goshcedule() to let it continue

go run -race main.go


to fix it we use mutex

locking the access to variable 

var mu sync.Mutex

and in logic we put 

mu.lock()
logic here
nobody can access counter var
mu.Unlock()

-------------------------------

Atomic 

from pacakge sync

addInt^4

when in go you see int64 --> almost atomic



----------------------------------------

Channels :
better way to sync your code .










