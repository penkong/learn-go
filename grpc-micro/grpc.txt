grpc with go

grpc is free , open source , part of CNFC like docker k8s

grpc allow to define req , res for rpc 
and handles rest for you .

built on http2


in client looks calling a function 

on client : server.createSth()
on server : createSth()

corba had rpc before.



grpc stub >>>>> grpc server
client ruby          c++ service
proto req _____ proto res 



define protocol buffers 
rest grpc will generate for you .

.proto works with 12 lang



----------

Theory :

grpc use protocol buffers
parsing JSON is cpu intense
grpc.io

stub == client

what is http2

http.1.1 dont compress headers , tcp , has not server push , req,res 
huge packaet size , latency 
is text, plainText

http2 it was spdy , multi pluxing , client and server push message in parallel
over same tcp , server push . header compression , 
is binary , it is secured by default by ssl .



4 types of api in grpc :
unary : classic req , res http

server streaming : client req, server res , res , res http2 

client streaming : client req , req, req , server res 

bi directional streaming : server streaming + client streaming


in message service 


this is bio
client side stream ------------- server side stream
rpc sth(stream sthGreet) returns (stream sthGreet2) {}





grpc server :
async 
can serve million requests in parallel



grpc clients :
async or sync
can perform client side load balancing
the client make dicsion withc model works best for performance 


grpc want ssl (encryption over wire)
interceptors , authentication 

grpc no api design need , api oriented , what you need >




--------------------------------------

Hands on : 


go get -u google.golang.org/grpc
go get -u github.com/golang/protobuf/protoc-gen-go



greet 
protoc greet/greetpb/greet.proto --go_out=plugins=grpc:.

after generate proto file for go 


make server 

first wee need listener 
with net pacakge on tcp 
grpc default port 50051

make listener 
make grpc server = grpc.NewServer(opts...)

protob file gen a register service server func 
on object we do this with 
grpc server and pointer
finally on grpc server s.Server(netListenerHere)




make client 


first create connection to server 
grpc.Dial(address , opts = grpc.WithInsecure())

after that create Client
from generated proto file NewGreetServiceClient



unary api :
most common
for data small 
for each rpc calls must define req and response message


for implementation :
server side :
server must have receiver func that implement interface
of rpc message generated by proto buf like 
rpc Greet == type interface GreetServiceServer { ...}

flow 
server runs 
we register client 
on client we define methods we want 
we issue req on client 
receiver func on server receiver req 
do logic with req 
produce res 
send res 
at same time res received on client 



unary style in server has access to ctx 
but streamer dont use it .



server streaming: http 
one send , receive many response

use for big data 

also for push data from server to client

when stream finishe we receive err == io.EOF

info are msg.GetResult()



client streaming :
many messge , one response
server can make decision when send response
for upload big file , when server process is expensive
to push to sever without want response.



bio directional :

when send data async from both side 

chat 
long running 





advanced :

error code 
grpc.io/docs/guides/error.html
avi.im/grpc-errors



dealines :
specify how your grpc must wait 


========================================================



SSL encryption with grpc :

must generate ssl cert 
end to end safe 

 

how ssl works ???
client 
user, pass
first we encrypt message 
send messge 
decrypt message 
server 



ssl old ---> tls (transport layer security)

tls encrypts connection between 2 end points

two ways of using ssl with grpc :
1 way : verification browser verify webServer (encryption)
2 way : ssl authentication (authentication)



setup :

client     server 

first 
need certification setup 
need to create certificate Authority (CA)
ca use for public api domain or internal sub domain api
private , public 
server create private key , PEM 
using that private key 
it would generate to request to sign certificate to CA for myapi(server address)
server say please sign my certificate request to CA
ca send back 
signed certificate
we receive 
server crt signed by CA

on client grpc side
we need trust certificate from CA  
CA issues for us CA ROOT or public certificate


therefore 
server use : cert , pem 
client use : public key 

after that ssl handshake happen 

server send signed ssl cert 
client verify ssl cert received from server
if ok 
ssl encryption happen




HANDS ON SSL CREATION :

we setup a c a 
we steup a server certificate
we sign a server cert

we set up a server  use tls 
we setup the client to conenct securely over tls 

link 
github.com/grpc/grpc-go/blob/master/documentaion/grpc-auth-support.md
grpc.io/docs/guides/auth.html


insturcution.sh file 




--------------------------------------


grpc reflection and cli :











